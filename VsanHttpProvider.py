#!/usr/bin/env python

"""
Copyright 2014 - 2017 VMware, Inc.  All rights reserved.
-- VMware Confidential

"""
__author__ = "VMware, Inc"

import os
import logging
import glob
import re
from VsanHclUtil import VsanHclUtil
import io
import zipfile
import six
from six.moves.urllib.request import urlopen
if six.PY3:
   from urllib.parse import unquote, quote
else:
   from urllib2 import unquote, quote

class VsanHttpProvider(object):

    @staticmethod
    def _getDummyZip():
       with io.BytesIO() as fp:
          zip = zipfile.ZipFile(fp, 'w')
          zip.writestr('empty', '')
          zip.close()
          return fp.getvalue()

    _dummyzip = _getDummyZip.__func__()

    def _getServerHealthResponse(self):
       dir = os.path.dirname(__file__)
       filename = os.path.join(dir, '..', 'health.xml')
       with open(filename, 'r') as fp:
          response = fp.read()
       responseCode = 200
       contentType = "application/xml"
       return (responseCode, response, contentType)

    def _doGetFileWithinZip(self, label, file, name = None, nameregex = None,
                            readIntoMemory = False):
       try:
          response = ""
          contentType = "application/octet-stream"
          with zipfile.ZipFile(file, 'r') as zf:
             if name is None:
                for item in zf.namelist():
                   if re.match(nameregex, item):
                      name = item
             if name is None:
                raise Exception("File %s not found with zip file" % nameregex)
             try:
                zf.getinfo(name)
             except KeyError:
                # file doesn't exist
                logging.error("No such file (%s) in zip (%s)" %
                              (name, file))
                return (404, "", "text/text")
             response = zf.read(name) if readIntoMemory else zf.open(name)
          if re.search(r"\.zip$", name):
             contentType = "application/zip"
          return (200, response, contentType)
       except IOError:
          logging.error("File not found: %s" % label)
          return (404, "", "text/text")

    def doGet(self, path, headers):
       response = ""
       vsanvpCatalogFile = re.match("/vsanHealth/vsanvp/catalogs/(\w+)/(\w+).vmsg", path)

       def getFilenameForFeatureBundle(feature):
          dir = os.path.dirname(__file__)
          filenamePrefix = os.path.join(dir,
                                        '..', feature, 'VMware-ESXi-')
          #logging.info("%s %s %s" % (feature, dir, filenamePrefix))
          files = glob.glob('%s*.zip' % filenamePrefix)
          #logging.info("files = %s" % str(files))
          filename = files[0]
          return filename

       if path == '/vsanHealth/hcl/dummy.zip':
         return (200, self._dummyzip, 'application/zip')

       if path == "/vsanHealth/vsan-h5-client.zip":
          logging.info("Fetching vsan-h5-client zip...")
          dir = os.path.dirname(__file__)
          filename = os.path.join(dir, '..', 'ui-plugins', 'vsan-h5-client.zip')
          with open(filename, 'rb') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "application/zip"
          return (responseCode, response, contentType)

       if path == "/vsanHealth/vsan-client.zip":
          logging.info("Fetching vsan-client zip...")
          dir = os.path.dirname(__file__)
          filename = os.path.join(dir, '..', 'ui-plugins', 'vsan-client.zip')
          with open(filename, 'rb') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "application/zip"
          return (responseCode, response, contentType)

       if path == "/vsanHealth/vropsPlugin.zip":
          logging.info("Fetching vropsPlugin zip...")
          dir = os.path.dirname(__file__)
          filename = os.path.join(dir, '..', 'ui-plugins', 'vropsPlugin.zip')
          with open(filename, 'rb') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "application/zip"
          return (responseCode, response, contentType)

       m = re.match("/vsanHealth/(\w+)-offline-bundle.zip$", path)
       if m:
          feature = m.group(1)
          filename = getFilenameForFeatureBundle(feature)
          logging.info("Serving %s" % filename)
          with open(filename, 'rb') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "application/zip"
          return (responseCode, response, contentType)

       m = re.match("/vsanHealth/(\w+)-offline-bundle.zip/(metadata|vib)$", path)
       if m:
          feature = m.group(1)
          filetype = m.group(2)
          if filetype == "metadata":
             nameregex = r"vmw-ESXi-(.*)-metadata\.zip"
          elif filetype == "vib":
             nameregex = r"vib20/(.*)\.vib"
          else:
             assert(False)
          filename = getFilenameForFeatureBundle(feature)
          logging.info("Serving %s within %s" % (nameregex, filename))
          return self._doGetFileWithinZip("%s offline bundle" % feature, filename,
                                          nameregex = nameregex)

       elif vsanvpCatalogFile or \
            path == "/vsanHealth/vsanvp/version.xml":
          filepath = path[12:]
          logging.info("Fetching vsanvp file: %s" % filepath)
          dir = os.path.dirname(__file__)
          filename = os.path.join(dir, filepath)
          with open(filename, 'r') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "text/xml"
          return (responseCode, response, contentType)
       elif path in ['/vsan/vsanhealth.wsdl', '/vsan/vsanhealthService.wsdl',
                     '/vsan/vsan.wsdl', '/vsan/vsanService.wsdl',
                     '/sdk/vim.wsdl', '/sdk/vimService.wsdl',
                     '/sdk/reflect-messagetypes.xsd',
                     '/sdk/vim-messagetypes.xsd',
                     '/sdk/query-messagetypes.xsd',
                     '/sdk/core-types.xsd',
                     '/sdk/query-types.xsd',
                     '/sdk/reflect-types.xsd',
                     '/sdk/vim-types.xsd',
                     '/vsanHealth/vsanvp/version.xml',
                    ]:
          dir = os.path.dirname(__file__)
          filename = os.path.join(dir, os.path.basename(path))
          with open(filename, 'rb') as fp:
             response = fp.read()
          responseCode = 200
          contentType = "text/xml"
          return (responseCode, response, contentType)
       elif path == "/vsanHealth/health":
          return self._getServerHealthResponse()
       # Decode the path
       path = unquote(path)
       # Download HCL files
       # HCL file itself
       m = re.match("^\/vsanHealth\/hcl\/([0-9a-f]{40})$",
                       path, re.IGNORECASE)
       if m:
          sha1 = m.group(1) # sha1 sum
          hclFile = VsanHclUtil.getFilenameFromSha1sum(sha1, validate = False)
          logging.debug("HCL file: " + hclFile)
          try:
             # XXX: optimize: this loads the entire file into memory
             with open(hclFile, 'rb') as fp:
                response = fp.read()
             responseCode = 200
             contentType = "application/octet-stream"
             return (responseCode, response, contentType)
          except IOError:
             logging.error("No file with the given sha1 found: " + sha1)
             return (404, "", "text/text")
       # Files within HCL files
       # E.g. /vsan/hcl/af65b1f85590e121438d459ee426f123f56d9a21/a/b/c.zip
       m = re.match("^\/vsanHealth\/hcl\/([0-9a-f]{40})\/(.*\.(vib|zip|scexe)$)",
                       path, re.IGNORECASE)
       if m:
          sha1 = m.group(1) # sha1 sum
          name = m.group(2) # file name with in the zip
          hclFile = VsanHclUtil.getFilenameFromSha1sum(sha1, validate = False)
          # Files within HCL wrapper file
          # /vsanHealth/hcl/af65b1f85590e121438d459ee426f123f56d9a21/wp.zip/b/c.zip
          subMatch = re.match("^(.*\.zip)\/(.*\.(vib|zip|scexe))$", name,
                              re.IGNORECASE)
          logging.debug("Inspecting zip file: " + hclFile)
          hclZipFile = hclFile
          if subMatch:
             wrapperName = subMatch.group(1) # wrapper file name within the zip
             name = subMatch.group(2)
             logging.debug("Inspecting wrapper file: " + hclFile)
             # Read the binary content from the zip
             wrapperRes = self._doGetFileWithinZip("sha1 %s" % sha1,
                                                       hclFile, wrapperName,
                                                       readIntoMemory = True)
             if wrapperRes[0] == 200:
                # There is not a problem for memoryIO without close
                hclZipFile = six.BytesIO(wrapperRes[1])
             else:
                return wrapperRes

          return self._doGetFileWithinZip("sha1 %s" % sha1, hclZipFile, name)

       # Handle offline bundle download request.
       # We need to download the offline bundle wrapper file, extract the
       # offline bundle file inside that zip file.
       m = re.match(r"^/vsanHealth/vum/driverOfflineBundle/(.*)$",
                    path, re.IGNORECASE)
       if m:
          url = unquote(m.group(1))
          logging.info("Download and unzip file " + url)
          try:
             response = urlopen(url)
             offlinebundlewrapperFile = six.BytesIO(response.read())
             # Extract offlinebundle from zip file.
             offlinebundleRes = self._doGetFileWithinZip(
                os.path.basename(url),
                offlinebundlewrapperFile,
                nameregex=r".*offline_bundle.*",
                readIntoMemory=True)
             return offlinebundleRes
          except Exception as ex:
             return (500, "Failed to download offlinebundle", "text/text")
       return (500, "", "text/text")
